

<h3 id="note">Note</h3>

<p>This is by far my most extensive experience as the main Backend architect on a project.
We created a micro service architecture from scratch.</p>

<h2 id="overview">Overview</h2>

<p>As a whole, the application polled Riot&rsquo;s API for new games, inserted them into the database through the API. When a new game is inserted, we run a webscraper for each player to get their latest stats. The application also polled Riot&rsquo;s API for recently ended games then updated them if they were present in the database. When a game was successfully ended we sent a Server Sent Event to every web browser to launch a success or completed modal to all users who bet on that game. Through the Web client, users are able to signup for an account, place bets on open games.</p>

<p>Our application components</p>

<ul>
<li>Web client written in Angular.js.</li>
<li>API written in Golang</li>
<li>PostgreSQL database</li>
<li>Website Scraper for LoLKing.com</li>
<li>Event Manager</li>
<li>Socket.io WebSockets</li>
</ul>

<p><img src="img/work/gamerbet/architecture.png" alt="Architecture" /></p>

<h4 id="web-client">Web client</h4>

<p>The web client was mostly written by my Co Founder Phil Swanson. It used websockets with a socket.io service to live update games and alert users on wins and losses.</p>

<h4 id="api">API</h4>

<p>The API consists of a set of HTTP handlers grouped into 3 different access levels: public, authenticated, and secret.</p>

<h5 id="public">Public</h5>

<p>Public contains all the HTTP requests that are necessary to view the site as a visitor and nothing more. Think, get open games, get leaderboard, and all other visual data.</p>

<h5 id="authenticated">Authenticated</h5>

<p>Authenticated routes are all routes specific to user actions, that require a logged in user.</p>

<p>We used token based authentication. The way token based auth works is a user enters a username and password. If the username and password are correct then we give them back a token and store their public user data as a value in Redis and use their token as the key. The client saves the token in their local storage and sends it on every request. Whenever a request is made, the API takes the token out of the HTTP headers and checks if Redis has a value on that key. If it does, we take the necessary data from redis and associate it with the given request. For example, a user is placing a bet. We take his user id and assign it to the new bet object so we&rsquo;ll know who placed that bet when it comes time to pay money out.</p>

<h5 id="secret-routes">Secret routes</h5>

<p>Secret routes are routes used only by internal services. They are given a unique token that only works with those routes. No client issued token will work with these routes and there are no login routes for these routes. For example, the event manager POSTs new games to the database. We don&rsquo;t want anyone but the event manager to post new games to the database, so we generated a single crypto secure token and hard coded in the event manager and the API.</p>

<h4 id="postgresql">PostgreSQL</h4>

<p>We used PostgreSQL as our database and used GORM Object Relational Mapper for most interaction and had a few routes using custom joins to optimize their speed.</p>

<p>We use primary keys, unique constraints and all the other goodies. Additionally, one thing I like to do is use the database for all my validation. I use CHECKs to check validate lengths and characters. It keeps all parts of my application in sync. Error messages are transformed into human readable text and bubbled up all the way to the client.</p>

<h4 id="website-scraper">Website Scraper</h4>

<p>Riot&rsquo;s API did not have any valuable player stats. Nor was there any other API that existed for this. We created a scraper for the most popular fan made website. It runs an exact match search on the website and returns the stats if the player is found.</p>

<h4 id="event-manager">Event Manager</h4>

<p>This is the most important peice of the application. My co-founder Phil wrote it originally in python. I later rewrote it in golang. It polled Riot&rsquo;s API for new games and for newly ended games. It then updated our database accordingly. After we realized people didn&rsquo;t care about amateur games (they only wanted to bet on pro players), we added a clause to only add games to our database that contained pro players in the match.</p>

